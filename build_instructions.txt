
######################################################################
                            TEMPORARY NOTE
######################################################################
All of the git repository URLs below now look something like this:

    https://github.com:alexelder/aspen-tools.git

Before we go "live" they will all be updated to look like this:

    https://github.com:linaro/poplar-tools.git

to reflect their final resting place.

In addition, I have described checking out branches named
"aspen-test".  Instead, we'll plan to have the "latest" branch
contain the latest code that's we believe to be the best version
of code for people to use.  That is, if one checks out "latest" of
all branches and builds them, the result should be expected to work.
Those names will change in this document before we publish this.
######################################################################

Building Poplar System Recovery Media From Source
-------------------------------------------------
The instructions that follow describe the process for creating a USB
flash drive suitable for use in recovering a Poplar system from a
"bricked" state.  The USB memory stick must be at least 8GB.

1)  Gather required sources

First you'll gather the source code and other materials required to
package a USB recovery device.

- Make sure you have needed tools installed.  This list may well
  grow, but at least you'll need the following:

      sudo apt-get install device-tree-compiler

- Set up the working directory.

  mkdir -p ~/src/poplar
  cd ~/src/poplar
  TOP=$(pwd)

- Download a root file system image to use.  These are available from
  Linaro.  An example is "linaro-stretch-developer-20170504-58.tar.gz",
  which is (or was) available here:
    http://snapshots.linaro.org/debian/images/stretch/developer-arm64/latest/
  Note that these images change regularly, so the image you get will
  be different from this.  If you download this file by some means
  other than "wget" shown below, please ensure it gets place in the
  "recovery" directory created here.

    mkdir ${TOP}/recovery
    wget -P ${TOP}/recovery \
        http://snapshots.linaro.org/debian/images/stretch/developer-arm64/latest/linaro-stretch-developer-20170504-58.tar.gz

- Get the source code:

  cd ${TOP}
  git clone https://github.com/alexelder/aspen-tools.git
  git clone https://github.com/alexelder/aspen-linux.git
  git clone https://github.com/alexelder/aspen-u-boot.git
  git clone https://github.com/alexelder/aspen-arm-trusted-firmware.git
  git clone https://github.com/alexelder/aspen-l-loader.git

- Set up branches to use, and make sure everything is clean:

    cd ${TOP}/aspen-linux
    git checkout -b aspen-test origin/aspen-test

    cd ${TOP}/aspen-u-boot
    git checkout -b aspen-test origin/aspen-test

    cd ${TOP}/aspen-arm-trusted-firmware
    git checkout -b aspen-test origin/aspen-test

    cd ${TOP}/aspen-l-loader
    git checkout -b aspen-test origin/aspen-test

- Prepare for building.  Almost everything is aarch64, but one item
  (l-loader.bin) must be built for 32-bit ARM.  Set up environment
  variables to represent the two cross-compiler toolchains you'll
  be using.

    CROSS_32=arm-linux-gnueabi-
    CROSS_64=aarch64-linux-gnu-

  If you don't already have ARM 32- and 64-bit toochains installed,
  they are available from Linaro.
    https://releases.linaro.org/components/toolchain/binaries/latest/
  Install the "aarch64-linux-gnu" and "arm-linux-gnueabi" packages
  for your system.  (Depending on where you install them, you may
  need to specify absolute paths for the values of CROSS_32 and
  CROSS_64.)

  Large builds (e.g Linux) are sped up considerably by running
  "make" with multiple concurrent jobs.  The command below sets
  JOBCOUNT to something reasonable to benefit from this.

    JOBCOUNT=$(grep ^processor /proc/cpuinfo | wc -w)

2)  Build everything

- Build U-Boot.  The result of this process will be a file
  "u-boot.bin" that will be incorporated into a "FIP" file created
  for ARM Trusted Firmware code.

    # This produces one output file, which is used when building ARM
    # Trusted Firmware, next:
    #       u-boot.bin
    cd ${TOP}/aspen-u-boot
    make distclean
    make CROSS_COMPILE=${CROSS_64} poplar_defconfig
    make CROSS_COMPILE=${CROSS_64} -j ${JOBCOUNT}

- Build ARM Trusted Firmware components.  This will create "bl1.bin"
  and "fip.bin", both of which will be incorporated into the image
  created for "l-loader".  The FIP file packages files "bl2.bin" and
  "bl31.bin" built here along with "u-boot.bin" built earlier into
  "fip.bin".  ARM Trusted Firmware keeps its output in a directory
  "build"; you'll create a symlink to that in our output directory,
  to keep things together.

    # This produces two output files, which are used when building
    # "l-loader", next:
    #       build/poplar/debug/bl1.bin
    #       build/poplar/debug/fip.bin
    cd ${TOP}/aspen-arm-trusted-firmware
    make distclean
    make CROSS_COMPILE=${CROSS_64} all fip DEBUG=1 PLAT=poplar SPD=none \
		       BL33=${TOP}/aspen-u-boot/u-boot.bin

- Build "l-loader".  First you'll gather the two ARM Trusted Firmware
  components you built into the "atf" directory.  Note that "l-loader"
  is a 32-bit executable, so you need to use a different tool chain.

    # This produces one output file, which is used in building the
    # USB flash drive:
    #       l-loader.bin
    mkdir -p ${TOP}/out/l-loader
    cd ${TOP}/aspen-l-loader
    cp ${TOP}/aspen-arm-trusted-firmware/poplar/debug/bl1.bin atf/
    cp ${TOP}/aspen-arm-trusted-firmware/poplar/debug/fip.bin atf/
    make clean
    make CROSS_COMPILE=${CROSS_32}

- Build Linux.  The result of this process will be two files: "Image"
  contains the kernel image; and "hi3798cv200-poplar.dtb" containing
  the flattened device tree file (device tree binary).

    # This produces two output files, which are used when building
    # the USB flash drive image:
    #       arch/arm64/boot/Image
    #       arch/arm64/boot/dts/hisilicon/hi3798cv200-poplar.dtb
    cd ${TOP}/aspen-linux
    make distclean
    make ARCH=arm64 CROSS_COMPILE="${CROSS_64}" defconfig
    make ARCH=arm64 CROSS_COMPILE="${CROSS_64}" -j ${JOBCOUNT}

- Gather the required components you built above in order to create
  the Poplar USB drive recovery image.

    cd ${TOP}/recovery
    cp ${TOP}/aspen-tools/poplar_recovery_builder.sh .
    cp ${TOP}/l-loader/l-loader.bin .
    cp ${TOP}/aspen-linux/arch/arm64/boot/Image .
    cp ${TOP}/aspen-linux/arch/arm64/boot/dts/hisilicon/hi3798cv200-poplar.dtb .

- Build an image to save to a USB flash drive for Poplar recovery.
  You need to supply the root file system image you downloaded
  earlier (whose name will be different from what's shown below).

    # This produces one output file, which is written to a USB flash drive:
    #       poplar_recovery_usb.img
    bash ./poplar_recovery_builder.sh \
		    linaro-stretch-developer-20170504-58.tar.gz

3)  Prepare to replace the contents of a USB flash drive with the
    output of the build.

- First you need to identify your USB flash drive.  THIS IS VERY
  IMPORTANT.  Step 3 will COMPLETELY ERASE the contents of whatever
  device you specify here.  So be sure you get it right.

    - Insert the USB flash drive into your host system.

    - Identify your USB device:

	grep . /sys/class/block/sd?/device/model

      If you recognize the model name as your USB flash device, then
      you know which "sd" device to use.  Here's an example:

	/sys/class/block/sdc/device/model:Patriot Memory
	                     ^^^
      I had a Patriot Memory USB flash drive, and the device name
      I'll want is "/dev/sdc" (based on "sdc" above).  Record this
      name:

	USBDISK=/dev/sdc	# Make sure this is *your* device

- Unmount anything on that USB flash drive that might have been
  automatically mounted when you inserted it.

    mount | grep ${USBDISK} | awk '{print $1}' | xargs sudo umount


3)  Overwrite the USB drive you have inserted with the built image.

- You will need superuser access.  And you'll need to answer "yes".

    read -i no -p "Overwrite ${USBDISK} (please type \"yes\")? " x
    [ ${x} = yes ] && sudo dd if=poplar_recovery_usb.img of=${USBDISK}

- Eject the USB flash drive,

    eject ${USBDISK}

- Remove the USB flash drive from your host system

4)  Run the recovery on the Poplar board

- Next you'll put the USB flash drive on the Poplar board to boot
  from it.  The Poplar board should be powered off.  You should have
  a cable from the Poplar's micro USB based serial port to your host
  system so you can connect and observe activity on the serial port.
  For me, the board console shows up as /dev/ttyUSB0 when the USB
  cable is connected.  The serial port runs at 115200 baud.  I use
  this command to see what's on the console:

      screen /dev/ttyUSB0 115200

- There are a total of 4 USB connectors on the Poplar board.  Two
  are USB 2.0 ports, they're stacked on top of each other.  Insert
  the USB memory stick into one of these two.

- There is a "USB_BOOT" button on the board.  It is one of two
  buttons on same side of the boards as the stacked USB2.0 ports.
  To boot from the memory stick, this button needs to be depressed
  at power-on.  You only need to hold it for about a second; keeping
  it down a bit longer does no harm.

- Hold the USB_BOOT button down, and power on the Poplar board.
  Release the USB_BOOT button after a second or two.  The board
  should boot, and the serial console should display boot messages.
  Since you have started with the USB_BOOT pressed, you'll be
  prompted with a message lke this:

    ==== POPLAR USB RECOVERY ====

    Are you sure you want to re-initialize your Poplar board?
    Please enter "yes" to proceed: 

- At this point, if you don't say "yes" *exactly* the recovery will
  be aborted and the board will proceed (finish its boot, and
  possibly auto-boot whatever is already loaded).

- If you say "yes" to initializing your board, the installation
  process will proceed.  You'll see some messages showing progress,
  like:

         RECOVERY STARTING

    starting USB...
    USB0:   USB EHCI 1.00
    scanning bus 0 for devices... 3 USB Device(s) found
           scanning usb for storage devices... 1 Storage Device(s) found
           scanning usb for ethernet devices... 0 Ethernet Device(s) found
    reading install.scr
    2321 bytes read in 21 ms (107.4 KiB/s)
    ## Executing script at 32000000
    reading mbr.gz
    174 bytes read in 15 ms (10.7 KiB/s)
    Uncompressed size: 512 = 0x200

    MMC write: dev # 0, block # 0, count 1 ... 1 blocks written: OK

    reading ebr5.bin.gz
    69 bytes read in 16 ms (3.9 KiB/s)
    Uncompressed size: 512 = 0x200
    . . .

  It will take about 10 minutes to complete writing out the contents
  of the disk.  When this is done, the board will automatically
  reset.

- Remove your USB memory stick from the Poplar board.

You have now booted your Poplar board with open source code that you
have built yourself.
